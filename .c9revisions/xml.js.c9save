{"ts":1344970093865,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * @name xml\r\n * @version 1.0\r\n * @author Sam Tsvilik\r\n * @description\r\n * This is a super light and simple XML to JSON converter.\r\n * All it does is scans through child elements of your XML and builds out a JSON structure.\r\n * To avoid attribute vs. node name conflicts - All attribute entities are prefixed with \"@\" (i.e. <node attr=\"1\"/> == {node: {\"@attr\":\"1\"}} )\r\n * Text or CDATA value will always be inside a \"Text\" property (i.e. myNodeObj.Text == <myNodeObj>Hello</myNodeObj> - Hello)\r\n * Node siblings with the same name will be automatically converted into arrays, else if node is singular it will just be an Object\r\n */\r\n(function(window, undef) { /** @lends xml */\r\n\t//Trim polyfill (thanks gist: 1035982)\r\n\t''.trim || (String.prototype.trim = function() {\r\n\t\treturn this.replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, '');\r\n\t});\r\n\r\n\tvar NULL = null,\r\n\t\tFALSE = !1,\r\n\t\tTRUE = !0,\r\n\t\tNODE_TYPES = {\r\n\t\t\tElement: 1,\r\n\t\t\tAttribute: 2,\r\n\t\t\tText: 3,\r\n\t\t\tCDATA: 4,\r\n\t\t\tRoot: 9,\r\n\t\t\tFragment: 11\r\n\t\t},\r\n\t\tXMLConverter, module;\r\n\r\n\t/**\r\n\t * Parses XML string and returns an XMLDocument object\r\n\t * @param  {String} strXML XML Formatted string\r\n\t * @return {XMLDocument|XMLElement}\r\n\t */\r\n\r\n\tfunction parseXMLString(strXML) {\r\n\t\tvar xmlDoc = NULL,\r\n\t\t\tout = NULL,\r\n\t\t\tisParsed = TRUE;\r\n\t\ttry {\r\n\t\t\txmlDoc = (\"DOMParser\" in window) ? new DOMParser() : new ActiveXObject(\"MSXML2.DOMDocument\");\r\n\t\t\txmlDoc.async = FALSE;\r\n\t\t} catch (e) {\r\n\t\t\tthrow new Error(\"XML Parser could not be instantiated\");\r\n\t\t}\r\n\r\n\t\tif (\"parseFromString\" in xmlDoc) {\r\n\t\t\tout = xmlDoc.parseFromString(strXML, \"text/xml\");\r\n\t\t\tisParsed = (out.documentElement.tagName !== \"parsererror\");\r\n\t\t} else { //If old IE\r\n\t\t\tisParsed = xmlDoc.loadXML(strXML);\r\n\t\t\tout = (isParsed) ? xmlDoc : FALSE;\r\n\t\t}\r\n\t\tif (!isParsed) {\r\n\t\t\tthrow new Error(\"Error parsing XML string\");\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n\tXMLConverter = {\r\n\t\tisXML: function(o) {\r\n\t\t\treturn (typeof(o) === \"object\" && o.nodeType !== undef);\r\n\t\t},\r\n\t\tgetRoot: function(doc) {\r\n\t\t\treturn (doc.nodeType === NODE_TYPES.Root) ? doc.documentElement : (doc.nodeType === NODE_TYPES.Fragment) ? doc.firstChild : doc;\r\n\t\t},\r\n\t\t/**\r\n\t\t * Begins the conversion process. Will automatically convert XML string into XMLDocument\r\n\t\t * @param  {String|XMLDocument|XMLNode|XMLElement} xml XML you want to convert to JSON\r\n\t\t * @return {JSON} JSON object representing the XML data tree\r\n\t\t */\r\n\t\tconvert: function(xml) {\r\n\t\t\tvar out = {},\r\n\t\t\t\txdoc = typeof(xml) === \"string\" ? parseXMLString(xml) : this.isXML(xml) ? xml : undef,\r\n\t\t\t\troot;\r\n\t\t\tif (!xdoc) {\r\n\t\t\t\tthrow new Error(\"Unable to parse XML\");\r\n\t\t\t}\r\n\t\t\t//If xdoc is just a text or CDATA return value\r\n\t\t\tif (xdoc.nodeType === NODE_TYPES.Text || xdoc.nodeType === NODE_TYPES.CDATA) {\r\n\t\t\t\treturn xdoc.nodeValue;\r\n\t\t\t}\r\n\t\t\t//Extract root node\r\n\t\t\troot = this.getRoot(xdoc);\r\n\t\t\t//Create first root node\r\n\t\t\tout[root.nodeName] = {};\r\n\t\t\t//Start assembling the JSON tree (recursive)\r\n\t\t\tthis.process(root, out[root.nodeName]);\r\n\t\t\t//Parse JSON string and attempt to return it as an Object\r\n\t\t\treturn out;\r\n\t\t},\r\n\t\t/**\r\n\t\t * Recursive xmlNode processor. It determines the node type and processes it accordingly.\r\n\t\t * @param  {XMLNode} node Any XML node\r\n\t\t * @param  {Object} buff Buffer object which will contain the JSON equivalent properties\r\n\t\t */\r\n\t\tprocess: function(node, buff) {\r\n\t\t\tvar child, attr, name, att_name, value, i, j, tmp, iMax, jMax;\r\n\t\t\tif (node.hasChildNodes()) {\r\n\t\t\t\tiMax = node.childNodes.length;\r\n\t\t\t\tfor (i = 0; i < iMax; i++) {\r\n\t\t\t\t\tchild = node.childNodes[i];\r\n\t\t\t\t\t//Check nodeType of each child node\r\n\t\t\t\t\tswitch (child.nodeType) {\r\n\t\t\t\t\tcase NODE_TYPES.Text:\r\n\t\t\t\t\t\t//If parent node has both CDATA and Text nodes, we just concatinate them together\r\n\t\t\t\t\t\tbuff.Text = buff.Text ? buff.Text + child.nodeValue.trim() : child.nodeValue.trim();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase NODE_TYPES.CDATA:\r\n\t\t\t\t\t\t//If parent node has both CDATA and Text nodes, we just concatinate them together\r\n\t\t\t\t\t\tvalue = child[child.text ? \"text\" : \"nodeValue\"]; //IE attributes support\r\n\t\t\t\t\t\tbuff.Text = buff.Text ? buff.Text + value : value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase NODE_TYPES.Element:\r\n\t\t\t\t\t\tname = child.nodeName;\r\n\t\t\t\t\t\ttmp = {};\r\n\t\t\t\t\t\t//Populate attributes\r\n\t\t\t\t\t\tjMax = child.attributes.length;\r\n\t\t\t\t\t\tif (jMax) {\r\n\t\t\t\t\t\t\tfor (j = jMax - 1; j >= 0; j--) {\r\n\t\t\t\t\t\t\t\tattr = child.attributes[j];\r\n\t\t\t\t\t\t\t\tatt_name = attr.name.trim();\r\n\t\t\t\t\t\t\t\tvalue = attr.value;\r\n\t\t\t\t\t\t\t\ttmp[\"@\" + att_name] = value;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//Node name already exists in the buffer and it's a NodeSet\r\n\t\t\t\t\t\tif (name in buff) {\r\n\t\t\t\t\t\t\tif (buff[name].length) {\r\n\t\t\t\t\t\t\t\tthis.process(child, tmp);\r\n\t\t\t\t\t\t\t\tbuff[name].push(tmp);\r\n\t\t\t\t\t\t\t} else { //If node exists in the parent as a single entity\r\n\t\t\t\t\t\t\t\tthis.process(child, tmp);\r\n\t\t\t\t\t\t\t\tbuff[name] = [buff[name], tmp];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else { //If node does not exist in the parent\r\n\t\t\t\t\t\t\tthis.process(child, tmp);\r\n\t\t\t\t\t\t\tbuff[name] = tmp;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tmodule = {\r\n\t\t/**\r\n\t\t * Public API to convert XML to JSON\r\n\t\t * @param  {String | XMLDocument} xml Any XML type\r\n\t\t * @return {JSON}     JSON object\r\n\t\t */\r\n\t\txmlToJSON: function(xml) {\r\n\t\t\treturn XMLConverter.convert(xml);\r\n\t\t}\r\n\t};\r\n\t//Expose public Api\r\n\twindow.xml = window.xml || module;\r\n})(window);"]],"start1":0,"start2":0,"length1":0,"length2":5826}]],"length":5826}
{"contributors":[],"silentsave":false,"ts":1351974081085,"patch":[[{"diffs":[[0," jMax;\r\n"],[-1,"\t\t\t"],[1,"            "],[0,"if"],[-1," "],[0,"(node.ha"]],"start1":3923,"start2":3923,"length1":22,"length2":30},{"diffs":[[0,"s()) {\r\n"],[-1,"\t\t\t\t"],[1,"                "],[0,"iMax = n"]],"start1":3963,"start2":3963,"length1":20,"length2":32},{"diffs":[[0,"ength;\r\n"],[-1,"\t\t\t\t"],[1,"                "],[0,"for"],[-1," "],[0,"(i = 0; "]],"start1":4011,"start2":4011,"length1":24,"length2":35},{"diffs":[[0,"i++) {\r\n"],[-1,"\t\t\t\t\t"],[1,"                    "],[0,"child = "]],"start1":4056,"start2":4056,"length1":21,"length2":36},{"diffs":[[0,"es[i];\r\n"],[-1,"\t\t\t\t\t"],[1,"                    "],[0,"//Check "]],"start1":4105,"start2":4105,"length1":21,"length2":36},{"diffs":[[0,"de\r\n"],[-1,"\t\t\t\t\t"],[1,"                    "],[0,"switch"],[-1," "],[0,"(chi"]],"start1":4166,"start2":4166,"length1":20,"length2":34},{"diffs":[[0,"ype) {\r\n"],[-1,"\t\t\t\t\t"],[1,"                    "],[0,"case NOD"]],"start1":4208,"start2":4208,"length1":21,"length2":36},{"diffs":[[0,".Text:\r\n"],[-1,"\t\t\t\t\t\t"],[1,"                        "],[0,"//If par"]],"start1":4251,"start2":4251,"length1":22,"length2":40},{"diffs":[[0,"gether\r\n"],[-1,"\t\t\t\t\t\t"],[1,"                        "],[0,"buff.Tex"]],"start1":4358,"start2":4358,"length1":22,"length2":40},{"diffs":[[0,".Text + "],[1,"$.trim("],[0,"child.no"]],"start1":4418,"start2":4418,"length1":16,"length2":23},{"diffs":[[0,"alue"],[1,") : $"],[0,".trim("],[-1,") : "],[0,"chil"]],"start1":4444,"start2":4444,"length1":18,"length2":19},{"diffs":[[0,"alue"],[-1,".trim();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase NODE_TYPES.CDATA:\r\n\t\t\t\t\t\t"],[1,");\r\n                        break;\r\n                    case NODE_TYPES.CDATA:\r\n                        "],[0,"//If"]],"start1":4470,"start2":4470,"length1":67,"length2":112},{"diffs":[[0,"gether\r\n"],[-1,"\t\t\t\t\t\t"],[1,"                        "],[0,"value = "]],"start1":4653,"start2":4653,"length1":22,"length2":40},{"diffs":[[0,"upport\r\n"],[-1,"\t\t\t\t\t\t"],[1,"                        "],[0,"buff.Tex"]],"start1":4752,"start2":4752,"length1":22,"length2":40},{"diffs":[[0,"e;\r\n"],[-1,"\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase NODE_TYPES.Element:\r\n\t\t\t\t\t\tname = child.nodeName;\r\n\t\t\t\t\t\ttmp = {};\r\n\t\t\t\t\t\t//Populate attributes\r\n\t\t\t\t\t\tjMax = child.attributes.length;\r\n\t\t\t\t\t\tif (jMax) {\r\n\t\t\t\t\t\t\tfor (j = jMax - 1; j >= 0; j--) {\r\n\t\t\t\t\t\t\t\tattr = child.attributes[j];\r\n\t\t\t\t\t\t\t\tatt_name = attr.name.trim();\r\n\t\t\t\t\t\t\t\tvalue = attr.value;\r\n\t\t\t\t\t\t\t\ttmp[\"@\" + att_name] = value;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t"],[1,"                        break;\r\n                    case NODE_TYPES.Element:\r\n                        name = child.nodeName;\r\n                        tmp = {};\r\n                        "],[0,"//No"]],"start1":4832,"start2":4832,"length1":396,"length2":193},{"diffs":[[0,"odeSet\r\n"],[-1,"\t\t\t\t\t\t"],[1,"                        "],[0,"if"],[-1," "],[0,"(name in"]],"start1":5074,"start2":5074,"length1":25,"length2":42},{"diffs":[[0," {\r\n"],[-1,"\t\t\t\t\t\t\t"],[1,"                            "],[0,"if"],[-1," "],[0,"(buf"]],"start1":5122,"start2":5122,"length1":18,"length2":38},{"diffs":[[0," {\r\n"],[-1,"\t\t\t\t\t\t\t\tthis.process(child, tmp);\r\n\t\t\t\t\t\t\t\tbuff[name].push(tmp);\r\n\t\t\t\t\t\t\t} else { //If node exists in the parent as a single entity\r\n\t\t\t\t\t\t\t\tthis.process(child, tmp);\r\n\t\t\t\t\t\t\t\tbuff[name] = [buff[name], tmp];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else { //If node does not exist in the parent\r\n\t\t\t\t\t\t\tthis.process(child, tmp);\r\n\t\t\t\t\t\t\tbuff[name] = tmp;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t"],[1,"                                this.process(child, tmp);\r\n                                buff[name].push(tmp);\r\n                            } else { //If node exists in the parent as a single entity\r\n                                this.process(child, tmp);\r\n                                buff[name] = [buff[name], tmp];\r\n                            }\r\n                        } else { //If node does not exist in the parent\r\n                            this.process(child, tmp);\r\n                            buff[name] = tmp;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //Populate attributes\r\n            if(node.attributes.length) {\r\n                jMax = node.attributes.length;\r\n                if(jMax) {\r\n                    for(j = jMax - 1; j >= 0; j--) {\r\n                        attr = node.attributes[j];\r\n                        att_name = $.trim(attr.name);\r\n                        value = attr.value;\r\n                        buff[\"@\" + att_name] = value;\r\n                    }\r\n                }\r\n            "],[0,"}\r\n\t"]],"start1":5175,"start2":5175,"length1":383,"length2":1124}]],"length":6616,"saved":false}
{"ts":1351974289002,"patch":[[{"diffs":[[0," jMax;\r\n"],[-1,"            "],[1,"\t\t\t"],[0,"if"],[1," "],[0,"(node.ha"]],"start1":3923,"start2":3923,"length1":30,"length2":22},{"diffs":[[0,"s()) {\r\n"],[-1,"                "],[1,"\t\t\t\t"],[0,"iMax = n"]],"start1":3955,"start2":3955,"length1":32,"length2":20},{"diffs":[[0,"ength;\r\n"],[-1,"                "],[1,"\t\t\t\t"],[0,"for"],[1," "],[0,"(i = 0; "]],"start1":3991,"start2":3991,"length1":35,"length2":24},{"diffs":[[0,"i++) {\r\n"],[-1,"                    "],[1,"\t\t\t\t\t"],[0,"child = "]],"start1":4025,"start2":4025,"length1":36,"length2":21},{"diffs":[[0,"es[i];\r\n"],[-1,"                    "],[1,"\t\t\t\t\t"],[0,"//Check "]],"start1":4059,"start2":4059,"length1":36,"length2":21},{"diffs":[[0,"de\r\n"],[-1,"                    "],[1,"\t\t\t\t\t"],[0,"switch"],[1," "],[0,"(chi"]],"start1":4105,"start2":4105,"length1":34,"length2":20},{"diffs":[[0,"ype) {\r\n"],[-1,"                    "],[1,"\t\t\t\t\t"],[0,"case NOD"]],"start1":4133,"start2":4133,"length1":36,"length2":21},{"diffs":[[0,"t:\r\n"],[-1,"                        "],[1,"\t\t\t\t\t\t"],[0,"//If"]],"start1":4165,"start2":4165,"length1":32,"length2":14},{"diffs":[[0,"er\r\n"],[-1,"                        "],[1,"\t\t\t\t\t\t"],[0,"buff"]],"start1":4254,"start2":4254,"length1":32,"length2":14},{"diffs":[[0,".Text + "],[-1,"$.trim("],[0,"child.no"]],"start1":4292,"start2":4292,"length1":23,"length2":16},{"diffs":[[0,"alue"],[-1,") : $"],[0,".trim("],[1,") : "],[0,"chil"]],"start1":4311,"start2":4311,"length1":19,"length2":18},{"diffs":[[0,"alue"],[-1,");\r\n                        break;\r\n                    case NODE_TYPES.CDATA:\r\n                        "],[1,".trim();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase NODE_TYPES.CDATA:\r\n\t\t\t\t\t\t"],[0,"//If"]],"start1":4336,"start2":4336,"length1":112,"length2":67},{"diffs":[[0,"er\r\n"],[-1,"                        "],[1,"\t\t\t\t\t\t"],[0,"valu"]],"start1":4478,"start2":4478,"length1":32,"length2":14},{"diffs":[[0,"rt\r\n"],[-1,"                        "],[1,"\t\t\t\t\t\t"],[0,"buff"]],"start1":4559,"start2":4559,"length1":32,"length2":14},{"diffs":[[0,"e;\r\n"],[-1,"                        break;\r\n                    case NODE_TYPES.Element:\r\n                        name = child.nodeName;\r\n                        tmp = {};\r\n                        "],[1,"\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase NODE_TYPES.Element:\r\n\t\t\t\t\t\tname = child.nodeName;\r\n\t\t\t\t\t\ttmp = {};\r\n\t\t\t\t\t\t"],[0,"//No"]],"start1":4617,"start2":4617,"length1":193,"length2":106},{"diffs":[[0,"et\r\n"],[-1,"                        "],[1,"\t\t\t\t\t\t"],[0,"if"],[1," "],[0,"(nam"]],"start1":4776,"start2":4776,"length1":34,"length2":17},{"diffs":[[0," {\r\n"],[-1,"                            "],[1,"\t\t\t\t\t\t\t"],[0,"if"],[1," "],[0,"(buf"]],"start1":4803,"start2":4803,"length1":38,"length2":18},{"diffs":[[0," {\r\n"],[-1,"                                this.process(child, tmp);\r\n                                buff[name].push(tmp);\r\n                            } else { //If node exists in the parent as a single entity\r\n                                this.process(child, tmp);\r\n                                buff[name] = [buff[name], tmp];\r\n                            }\r\n                        } else { //If node does not exist in the parent\r\n                            this.process(child, tmp);\r\n                            buff[name] = tmp;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            "],[1,"\t\t\t\t\t\t\t\tthis.process(child, tmp);\r\n\t\t\t\t\t\t\t\tbuff[name].push(tmp);\r\n\t\t\t\t\t\t\t} else { //If node exists in the parent as a single entity\r\n\t\t\t\t\t\t\t\tthis.process(child, tmp);\r\n\t\t\t\t\t\t\t\tbuff[name] = [buff[name], tmp];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else { //If node does not exist in the parent\r\n\t\t\t\t\t\t\tthis.process(child, tmp);\r\n\t\t\t\t\t\t\tbuff[name] = tmp;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t"],[0,"}\r\n "]],"start1":4836,"start2":4836,"length1":653,"length2":383}]],"length":6007,"saved":false}
{"ts":1351974305035,"patch":[[{"diffs":[[0,"e = "],[-1,"$.trim("],[0,"attr"]],"start1":5508,"start2":5508,"length1":15,"length2":8},{"diffs":[[0,"ttr.name"],[1,".trim("],[0,");\r\n    "]],"start1":5513,"start2":5513,"length1":16,"length2":22}]],"length":6006,"saved":false}
{"ts":1351974374217,"patch":[[{"diffs":[[0,"        "],[-1,"jMax"],[1,"for(j"],[0," = node."]],"start1":5303,"start2":5303,"length1":20,"length2":21},{"diffs":[[0,"ngth"],[-1,";\r\n                if(jMax) {\r\n                    for(j = jMax"],[0," - 1"]],"start1":5337,"start2":5337,"length1":71,"length2":8},{"diffs":[[0," 0; j--) {\r\n"],[-1,"    "],[0,"            "]],"start1":5351,"start2":5351,"length1":28,"length2":24},{"diffs":[[0,"        "],[-1,"    "],[0,"att_name"]],"start1":5423,"start2":5423,"length1":20,"length2":16},{"diffs":[[0,"rim();\r\n"],[-1,"    "],[0,"        "]],"start1":5453,"start2":5453,"length1":20,"length2":16},{"diffs":[[0,"        "],[-1,"    "],[0,"buff[\"@\""]],"start1":5514,"start2":5514,"length1":20,"length2":16},{"diffs":[[0,"e;\r\n"],[-1,"                    }\r\n"],[0,"    "]],"start1":5549,"start2":5549,"length1":31,"length2":8}]],"length":5905,"saved":false}
